default:
    image:
        name: hashicorp/terraform
        entrypoint: [""]
    timeout: 15 minutes
    cache:
        - key: $CI_PIPELINE_ID-terraform-cache
          paths:
              - ./terraform/environments/${TF_ENV}/${TF_STATE}/.terraform/
              - ./terraform/environments/${TF_ENV}/${TF_STATE}/.terraform.lock.hcl

variables:
    STATE_FILENAME: ${TF_ENV}-${TF_STATE}
    TF_ADDRESS: "https://gitlab.hr-link.ru/api/v4/projects/${CI_PROJECT_ID}/terraform/state/${STATE_FILENAME}"
    ANSIBLE_HOST_KEY_CHECKING: "False"

#   # предполагается что в самом gitlab-е КАК ФАЙЛ определены переменные ALL & COMMON & TEST & STAGING
#   # внутри этих файлов должны быть записаны собственно переменные окружения необходимые проекту
#   cloud_config
#   ssh_private_key
#   env_all
#   env_common
#   env_test
#   env_dev
#   env_staging
#   env_ansible

#   TF_USERNAME
#   TF_PASSWORD

#   SSH_USER

#   # в этой переменной должен быть записан абсолютный путь до ansible.cfg, иначе ansible внутри контейнера игнорирует конфиг
#   ANSIBLE_CONFIG

#   # переменные с публичными ssh-ключами
#   PUB_TESTER

stages:
    - format
    - init
    - validate
    - security-scan
    - plan
    - apply
    - configure
    - destroy

format:
    stage: format
    rules:
        - if: $TF_ENV && $TF_STATE
          when: always
    script:
        - terraform -chdir="./terraform/environments/${TF_ENV}/${TF_STATE}" fmt
    cache: []
    allow_failure: true

download_provider:
    stage: init
    rules:
        - if: $TF_ENV && $TF_STATE
          when: always
    script:
        - env_name="env_${TF_ENV}"
        - env_file=$(eval "echo \$$env_name")
        - ls $env_all 2>/dev/null && source $env_all
        - ls $env_file 2>/dev/null && source $env_file
        - cp ./terraform/.terraformrc ~/.terraformrc
        - terraform -chdir="./terraform/environments/${TF_ENV}/${TF_STATE}" init
          -backend-config=address=${TF_ADDRESS}
          -backend-config=lock_address=${TF_ADDRESS}/lock
          -backend-config=unlock_address=${TF_ADDRESS}/lock
          -backend-config=username=${TF_USERNAME}
          -backend-config=password=${TF_PASSWORD}
          -backend-config=lock_method=POST
          -backend-config=unlock_method=DELETE
          -backend-config=retry_wait_min=5

validate:
    stage: validate
    rules:
        - if: $TF_ENV && $TF_STATE
          when: always
    script:
        - terraform -chdir="./terraform/environments/${TF_ENV}/${TF_STATE}" validate
    allow_failure: true

.scan:
    stage: security-scan
    #   rules:
    #     - if: $TF_ENV && $TF_STATE
    #       when: always
    image:
        name: aquasec/tfsec-ci
        entrypoint: [""]
    script:
        - tfsec . # путь к запускаемому проекту?..
    allow_failure: true

plan:
    stage: plan
    rules:
        - if: $TF_ENV && $TF_STATE
          when: always
    script:
        - env_name="env_${TF_ENV}"
        - env_file=$(eval "echo \$$env_name")
        - ls $env_all 2>/dev/null && source $env_all
        - ls $env_file 2>/dev/null && source $env_file
        - terraform -chdir="./terraform/environments/$TF_ENV/$TF_STATE" plan -out output.tfplan

    # TODO сделать артефактом файл с результатом plan, в apply использовать этот артефакт
    artifacts:
        name: "${CI_JOB_NAME}-${CI_JOB_ID}-tfplan"
        paths:
            - ./terraform/environments/$TF_ENV/$TF_STATE/output.tfplan
        # expire_in: 1 day

apply_configuration:
    stage: apply
    rules:
        - if: $TF_ENV && $TF_STATE
          when: manual
    script:
        - env_name="env_${TF_ENV}"
        - env_file=$(eval "echo \$$env_name")
        - ls $env_all 2>/dev/null && source $env_all
        - ls $env_file 2>/dev/null && source $env_file
        - terraform -chdir="./terraform/environments/$TF_ENV/$TF_STATE" apply -auto-approve output.tfplan

    allow_failure: true

    # сохранение артефакта, артефакт здесь - inventory файл, он потом будет использоваться ansible-ом
    artifacts:
        name: "${CI_JOB_NAME}-${CI_JOB_ID}-inventory"
        paths:
            - ./ansible/inventory/$TF_ENV/inventory
        # expire_in: 1 day

ansible:
    image:
        name: alpinelinux/ansible
        entrypoint: [""]
    rules:
        - if: $TF_ENV && $TF_STATE
          when: manual
    stage: configure
    dependencies:
        - apply_configuration
    script:
        - ansible --version
        - eval $(ssh-agent -s)
        - chmod 400 "$ssh_private_key"
        - ssh-add "$ssh_private_key"
        - mkdir -p ~/.ssh
        - chmod 700 ~/.ssh
        - cd ./ansible
        - ansible-config view
        - ansible-galaxy collection install ansible.posix
        - ls -al ./inventory/$TF_ENV 2>/dev/null
        - cat ./inventory/$TF_ENV/inventory 2>/dev/null
        - sleep 40
        - source "$env_ansible" && ansible-playbook -u $SSH_USER ./playbooks/$TF_ENV.yaml
        - cd -

        # # TODO если получится понять как узнать $HOST, то можно использовать, заменив sleep 40
        # - while ! ssh -q -o BatchMode=yes -o ConnectTimeout=5 -o StrictHostKeyChecking=no -i "$ssh_private_key" $SSH_USER@$HOST "echo 2>&1"; do sleep 10; done && ansible-playbook -u $SSH_USER ./playbooks/$TF_ENV.yaml
    allow_failure: true
    cache: []

destroy_infra:
    stage: destroy
    rules:
        - if: $TF_ENV && $TF_STATE
          when: manual
    script:
        - env_name="env_${TF_ENV}"
        - env_file=$(eval "echo \$$env_name")
        - ls $env_all 2>/dev/null && source $env_all
        - ls $env_file 2>/dev/null && source $env_file
        - terraform -chdir="./terraform/environments/$TF_ENV/$TF_STATE" destroy -auto-approve
