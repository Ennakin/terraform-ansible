default:
    image:
        name: hashicorp/terraform
        entrypoint: [""]
    timeout: 15 minutes
    cache:
        - key: $CI_PIPELINE_ID-terraform-cache
          paths:
              - ./terraform/environments/${TF_ENV}/${TF_STATE}/.terraform/
              - ./terraform/environments/${TF_ENV}/${TF_STATE}/.terraform.lock.hcl

variables:
    STATE_FILENAME: ${TF_ENV}-${TF_STATE}
    TF_ADDRESS: "https://gitlab.hr-link.ru/api/v4/projects/${CI_PROJECT_ID}/terraform/state/${STATE_FILENAME}"
    ANSIBLE_HOST_KEY_CHECKING: "False"

#   # предполагается что в самом gitlab-е определены переменные следующие переменные
#   # внутри этих файлов должны быть записаны собственно переменные окружения необходимые проекту

#   # как ФАЙЛ

#   cloud_config
#   ssh_private_key
#   yc_key_secret_file

#   env_tf_all
#   env_tf_common
#   env_tf_dev
#   env_tf_test
#   env_tf_devops
#   env_tf_staging
#   env_tf_onprem
#   env_tf_prod

#   env_ansible_all
#   env_ansible_common
#   env_ansible_dev
#   env_ansible_test
#   env_ansible_devops
#   env_ansible_staging
#   env_ansible_onprem
#   env_ansible_prod

#   # как ПЕРЕМЕННАЯ

#   TF_USERNAME
#   TF_PASSWORD

#   SSH_USER

#   # переменная с абсолютным путём до ansible.cfg, иначе ansible внутри контейнера игнорирует конфиг
#   ANSIBLE_CONFIG

#   # переменные с публичными ssh-ключами
#   PUB_DEVELOPER
#   PUB_TESTER
#   PUB_ENGINEER
#   PUB_SYSTEMS_ANALYST
#   PUB_KASPER_OUTSOURCE

stages:
    - format
    - init
    - validate
    - security-scan
    - create-iam
    - plan
    - apply
    - configure
    - destroy

.format:
    rules:
        - if: $TF_ENV # && $TF_STATE
          when: always
    stage: format
    script:
        - terraform -chdir="./terraform/environments/${TF_ENV}/${TF_STATE}" fmt
    cache: []
    allow_failure: true

format-compute:
    extends:
    - .format
    rules: &compute-rules        
        - exists: 
          - terraform/environments/${TF_ENV}/compute/*.tf
          variables: 
            TF_STATE: compute
format-fs:
    extends:
    - .format
    rules: &fs-rules        
        - exists: 
          - terraform/environments/${TF_ENV}/fs/*.tf
          variables: 
            TF_STATE: fs
format-disk:
    extends:
    - .format
    rules: &disk-rules        
        - exists: 
          - terraform/environments/${TF_ENV}/disk/*.tf
          variables: 
            TF_STATE: disk
format-network:
    extends:
    - .format
    rules: &network-rules        
        - exists: 
          - terraform/environments/${TF_ENV}/network/*.tf
          variables: 
            TF_STATE: network


.init:
    stage: init
    rules:
        - if: $TF_ENV # && $TF_STATE
          when: always
        - exists: 
          - $env_file
          - $env_file
    script:
        - env_name="env_tf_${TF_ENV}"
        - env_file=$(eval "echo \$$env_name")
        - source $env_tf_all
        - source $env_file
        - cp ./terraform/.terraformrc ~/.terraformrc
        - terraform -chdir="./terraform/environments/${TF_ENV}/${TF_STATE}" init
          -backend-config=address=${TF_ADDRESS}
          -backend-config=lock_address=${TF_ADDRESS}/lock
          -backend-config=unlock_address=${TF_ADDRESS}/lock
          -backend-config=username=${TF_USERNAME}
          -backend-config=password=${TF_PASSWORD}
          -backend-config=lock_method=POST
          -backend-config=unlock_method=DELETE
          -backend-config=retry_wait_min=5

init-compute:
    extends:
      - .init
    rules: *compute-rules

init-fs:
    extends:
      - .init
    rules: *fs-rules

init-disk:
    extends:
      - .init
    rules: *disk-rules

init-network:
    extends:
      - .init
    rules: *network-rules

.validate:
    stage: validate
    rules:
        - if: $TF_ENV && $TF_STATE
          when: always
    script:
        - terraform -chdir="./terraform/environments/${TF_ENV}/${TF_STATE}" validate
    allow_failure: true

validate-compute:
    extends:
      - .validate
    rules: *compute-rules

validate-fs:
    extends:
      - .validate
    rules: *fs-rules

validate-disk:
    extends:
      - .validate
    rules: *disk-rules

validate-network:
    extends:
      - .validate
    rules: *network-rules

.scan:
    stage: security-scan
    #   rules:
    #     - if: $TF_ENV && $TF_STATE
    #       when: always
    image:
        name: aquasec/tfsec-ci
        entrypoint: [""]
    script:
        - tfsec . # путь к запускаемому проекту?..
    allow_failure: true

create-iam:
    stage: create-iam
    rules:
        - if: $TF_ENV # && $TF_STATE
          when: always
    script:
        - apk add --update --no-cache python3 py3-requests py3-jwt py3-cryptography && ln -sf python3 /usr/bin/python
        - python3 -V
        - source $env_tf_all && python3 ./terraform/py/ya-iam.py
    artifacts:
        name: "${CI_JOB_NAME}-${CI_JOB_ID}-iam-token"
        paths:
            - ./terraform/envs/prod/iam-token.env
        expire_in: 1 day

.plan:
    stage: plan
    rules:
        - if: $TF_ENV && $TF_STATE
          when: always
    script:
        - terraform -version
        - env_name="env_tf_${TF_ENV}"
        - env_file=$(eval "echo \$$env_name")
        - ls $env_tf_all 2>/dev/null && source $env_tf_all
        - ls $env_file 2>/dev/null && source $env_file
        - ls -al ./terraform/py/
        - source ./terraform/envs/prod/iam-token.env && terraform -chdir="./terraform/environments/$TF_ENV/$TF_STATE" plan -out output.tfplan
        # - terraform -chdir="./terraform/environments/$TF_ENV/$TF_STATE" plan -out output.tfplan

    # TODO сделать артефактом файл с результатом plan, в apply использовать этот артефакт
    artifacts:
        name: "${CI_JOB_NAME}-${CI_JOB_ID}-tfplan"
        paths:
            - ./terraform/environments/$TF_ENV/$TF_STATE/output.tfplan
        # expire_in: 1 day

plan-compute:
    extends:
      - .plan
    rules: *compute-rules

plan-fs:
    extends:
      - .plan
    rules: *fs-rules

plan-disk:
    extends:
      - .plan
    rules: *disk-rules

plan-network:
    extends:
      - .plan
    rules: *network-rules

.apply_configuration:
    stage: apply
    rules:
        - if: $TF_ENV && $TF_STATE
          when: manual
    script:
        - terraform -version
        - env_name="env_tf_${TF_ENV}"
        - env_file=$(eval "echo \$$env_name")
        - ls $env_tf_all 2>/dev/null && source $env_tf_all
        - ls $env_file 2>/dev/null && source $env_file
        - ls -al ./terraform/py/
        - source ./terraform/envs/prod/iam-token.env && terraform -chdir="./terraform/environments/$TF_ENV/$TF_STATE" apply -auto-approve output.tfplan
        # - terraform -chdir="./terraform/environments/$TF_ENV/$TF_STATE" apply -auto-approve output.tfplan

    allow_failure: true

    # сохранение артефакта, артефакт здесь - inventory файл, он потом будет использоваться ansible-ом
    artifacts:
        name: "${CI_JOB_NAME}-${CI_JOB_ID}-inventory"
        paths:
            - ./ansible/inventory/$TF_ENV/inventory
        # expire_in: 1 day

apply-compute:
    extends:
      - .apply_configuration
    rules: *compute-rules

apply-fs:
    extends:
      - .apply_configuration
    rules: *fs-rules

apply-disk:
    extends:
      - .apply_configuration
    rules: *disk-rules

apply-network:
    extends:
      - .apply_configuration
    rules: *network-rules

ansible:
    image:
        # name: alpinelinux/ansible
        name: litmuschaos/ansible-runner:3.5.0
        entrypoint: [""]
    rules:
        - if: $TF_ENV && $TF_STATE
          when: manual
    stage: configure
    dependencies:
        - apply_configuration
    script:
        #- ansible --version
        #- wget -O /etc/apk/keys/sgerrand.rsa.pub https://alpine-pkgs.sgerrand.com/sgerrand.rsa.pub
        #- echo "https://dl-cdn.alpinelinux.org/alpine/edge/main" > /etc/apk/repositories
        #- echo "https://dl-cdn.alpinelinux.org/alpine/edge/community" >> /etc/apk/repositories
        #- echo "https://dl-cdn.alpinelinux.org/alpine/edge/testing" >> /etc/apk/repositories
        #- apk update --allow-untrusted && apk update --no-cache && apk add ansible
        - ansible --version
        - eval $(ssh-agent -s)
        - chmod 400 "$ssh_private_key"
        - ssh-add "$ssh_private_key"
        - mkdir -p ~/.ssh
        - chmod 700 ~/.ssh
        - cd ./ansible
        - ansible-config view
        # - ansible-galaxy collection install ansible.posix
        - ls -al ./inventory/$TF_ENV 2>/dev/null
        - cat ./inventory/$TF_ENV/inventory 2>/dev/null
        - sleep 40
        - env_name="env_ansible_${TF_ENV}"
        - env_file=$(eval "echo \$$env_name")
        - ls $env_ansible_all 2>/dev/null && source $env_ansible_all
        - ls $env_file 2>/dev/null && source $env_file
        - ansible-playbook -u $SSH_USER ./playbooks/$TF_ENV.yaml
        - cd -

        # # TODO если получится понять как узнать $HOST, то можно использовать, заменив sleep 40
        # - while ! ssh -q -o BatchMode=yes -o ConnectTimeout=5 -o StrictHostKeyChecking=no -i "$ssh_private_key" $SSH_USER@$HOST "echo 2>&1"; do sleep 10; done && ansible-playbook -u $SSH_USER ./playbooks/$TF_ENV.yaml
    allow_failure: true
    cache: []

destroy_infra:
    stage: destroy
    rules:
        - if: $TF_ENV && $TF_STATE
          when: manual
    script:
        - env_name="env_tf_${TF_ENV}"
        - env_file=$(eval "echo \$$env_name")
        - ls $env_tf_all 2>/dev/null && source $env_tf_all
        - ls $env_file 2>/dev/null && source $env_file
        - ls -al ./terraform/py/
        - source ./terraform/envs/prod/iam-token.env && terraform -chdir="./terraform/environments/$TF_ENV/$TF_STATE" destroy -auto-approve
        # - terraform -chdir="./terraform/environments/$TF_ENV/$TF_STATE" destroy -auto-approve
