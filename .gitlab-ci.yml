default:
    image:
        name: docker.hr-link.ru/hashicorp/terraform:1.8
        entrypoint: [""]
    timeout: 15 minutes
    cache:
        - key: $CI_PIPELINE_ID-terraform-cache
          paths:
              - ./terraform/environments/${TF_ENV}/${TF_STATE}/.terraform/
              - ./terraform/environments/${TF_ENV}/${TF_STATE}/.terraform.lock.hcl

variables:
    STATE_FILENAME: ${TF_ENV}-${TF_STATE}
    TF_ADDRESS: "https://gitlab.hr-link.ru/api/v4/projects/${CI_PROJECT_ID}/terraform/state/${STATE_FILENAME}"
    ANSIBLE_HOST_KEY_CHECKING: "False"

# # предполагается что в самом gitlab проекте определены следующие переменные

# ########## для terraform ##########

# # как ФАЙЛ

# CLOUD_CONFIG (внутри cloud-config)
# YC_KEY_SECRET_FILE (внутри приватный ключ)

# # как ПЕРЕМЕННАЯ

# TF_USERNAME
# TF_PASSWORD
# TF_VAR_cloud_config_file_path=${CLOUD_CONFIG}

# ########## для ansible ##########

# # как ФАЙЛ
# SSH_PRIVATE_KEY (внутри приватный ключ)

# # как ПЕРЕМЕННАЯ

# SSH_USER
# DOCKER_HUB_PASSWORD
# PASSWORDS_SALT
# USER_PASSWORDS

# # переменная с абсолютным путём до ansible.cfg, иначе ansible внутри контейнера игнорирует конфиг
# ANSIBLE_CONFIG

# # переменные с публичными ssh-ключами
# PUB_DEVELOPER
# PUB_TESTER
# PUB_ENGINEER
# PUB_SYSTEMS_ANALYST
# PUB_KASPER_OUTSOURCE
# PUB_PFLB_OUTSOURCE

stages:
    - format
    - init
    - validate
    - security-scan
    - create-iam
    - plan
    - apply
    - configure
    - destroy

format:
    stage: format
    rules:
        - if: $TF_ENV && $TF_STATE
          when: always
    script:
        - terraform -chdir="./terraform/environments/${TF_ENV}/${TF_STATE}" fmt
    cache: []
    allow_failure: true

download_provider:
    stage: init
    rules:
        - if: $TF_ENV && $TF_STATE
          when: always
    script:
        - cp ./terraform/.terraformrc ~/.terraformrc
        - terraform -chdir="./terraform/environments/${TF_ENV}/${TF_STATE}" init
          -backend-config=address=${TF_ADDRESS}
          -backend-config=lock_address=${TF_ADDRESS}/lock
          -backend-config=unlock_address=${TF_ADDRESS}/lock
          -backend-config=username=${TF_USERNAME}
          -backend-config=password=${TF_PASSWORD}
          -backend-config=lock_method=POST
          -backend-config=unlock_method=DELETE
          -backend-config=retry_wait_min=5

validate:
    stage: validate
    rules:
        - if: $TF_ENV && $TF_STATE
          when: always
    script:
        - terraform -chdir="./terraform/environments/${TF_ENV}/${TF_STATE}" validate
    allow_failure: true

.scan:
    stage: security-scan
    #   rules:
    #     - if: $TF_ENV && $TF_STATE
    #       when: always
    image:
        name: aquasec/tfsec-ci
        entrypoint: [""]
    script:
        - tfsec . # путь к запускаемому проекту?..
    allow_failure: true

create-iam:
    stage: create-iam
    rules:
        - if: $TF_ENV && $TF_STATE
          when: always
    script:
        - apk add --update --no-cache python3 py3-requests py3-jwt py3-cryptography && ln -sf python3 /usr/bin/python
        - python3 -V
        - python3 ./terraform/py/ya-iam.py
    artifacts:
        name: "${CI_JOB_NAME}-${CI_JOB_ID}-iam-token"
        paths:
            - ./terraform/envs/prod/iam-token.env
        expire_in: 1 day

plan:
    stage: plan
    rules:
        - if: $TF_ENV && $TF_STATE
          when: always
    script:
        - terraform -version
        - ls -al ./terraform/py/
        - source ./terraform/envs/prod/iam-token.env && terraform -chdir="./terraform/environments/$TF_ENV/$TF_STATE" plan -out output.tfplan
        # - terraform -chdir="./terraform/environments/$TF_ENV/$TF_STATE" plan -out output.tfplan

    # TODO сделать артефактом файл с результатом plan, в apply использовать этот артефакт
    artifacts:
        name: "${CI_JOB_NAME}-${CI_JOB_ID}-tfplan"
        paths:
            - ./terraform/environments/$TF_ENV/$TF_STATE/output.tfplan
        # expire_in: 1 day

apply_configuration:
    stage: apply
    rules:
        - if: $TF_ENV && $TF_STATE
          when: manual
    script:
        - terraform -version
        - ls -al ./terraform/py/
        - source ./terraform/envs/prod/iam-token.env && terraform -chdir="./terraform/environments/$TF_ENV/$TF_STATE" apply -auto-approve output.tfplan
        # - terraform -chdir="./terraform/environments/$TF_ENV/$TF_STATE" apply -auto-approve output.tfplan

    allow_failure: true

    # сохранение артефакта, артефакт здесь - inventory файл, он потом будет использоваться ansible-ом
    artifacts:
        name: "${CI_JOB_NAME}-${CI_JOB_ID}-inventory"
        paths:
            - ./ansible/environments/$TF_ENV/inventory
        # expire_in: 1 day

ansible:
    image:
        # name: docker.hr-link.ru/alpinelinux/ansible:latest
        name: docker.hr-link.ru/litmuschaos/ansible-runner:3.5.0
        entrypoint: [""]
    rules:
        - if: $TF_ENV && $TF_STATE
          when: manual
    stage: configure
    dependencies:
        - apply_configuration
    script:
        #- ansible --version
        #- wget -O /etc/apk/keys/sgerrand.rsa.pub https://alpine-pkgs.sgerrand.com/sgerrand.rsa.pub
        #- echo "https://dl-cdn.alpinelinux.org/alpine/edge/main" > /etc/apk/repositories
        #- echo "https://dl-cdn.alpinelinux.org/alpine/edge/community" >> /etc/apk/repositories
        #- echo "https://dl-cdn.alpinelinux.org/alpine/edge/testing" >> /etc/apk/repositories
        #- apk update --allow-untrusted && apk update --no-cache && apk add ansible
        - bash --version
        - ansible --version
        - eval $(ssh-agent -s)
        - chmod 400 "$SSH_PRIVATE_KEY"
        - ssh-add "$SSH_PRIVATE_KEY"
        - mkdir -p ~/.ssh
        - chmod 700 ~/.ssh
        - cd ./ansible
        - ansible-config view
        # - ansible-galaxy collection install ansible.posix
        - ls -al ./environments/$TF_ENV 2>/dev/null
        - cat ./environments/$TF_ENV/inventory 2>/dev/null
        - sleep 40
        - ansible-playbook -u $SSH_USER ./playbooks/$TF_ENV.yaml $ANSIBLE_PARAMS
        - cd -

        # # TODO если получится понять как узнать $HOST, то можно использовать, заменив sleep 40
        # - while ! ssh -q -o BatchMode=yes -o ConnectTimeout=5 -o StrictHostKeyChecking=no -i "$ssh_private_key" $SSH_USER@$HOST "echo 2>&1"; do sleep 10; done && ansible-playbook -u $SSH_USER ./playbooks/$TF_ENV.yaml
    allow_failure: true
    cache: []

.destroy_infra:
    stage: destroy
    rules:
        - if: $TF_ENV && $TF_STATE
          when: manual
    script:
        - ls -al ./terraform/py/
        - source ./terraform/envs/prod/iam-token.env && terraform -chdir="./terraform/environments/$TF_ENV/$TF_STATE" destroy -auto-approve
        # - terraform -chdir="./terraform/environments/$TF_ENV/$TF_STATE" destroy -auto-approve
